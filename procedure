-모든 RDBMS에 Procedure는 다 있음(Oracle은 Pl/sql이라고 함)
-쿼리 파라미터가 넘어오면 쿼리를 날리고 처리를 절차적으로 수행함
-DB>프로그래밍기능>저장 프로시져
-함수는 결과값이 1줄이거나 단순처리.
-프로시져는 결과값 여러줄이 가능. 쿼리가 네트워크를 타고 DB에 전달되는데 프로시저를 쓰면 단 한번의 요청으로 여러 SQL 실행. 데이터 무결성 보장
-insert와 같은 모든 단계들을 프로시져를 사용해서 처리해왔었으나 최근에는 JPA를 사용(JPA는 서버 메모리에 올리기 때문에 속도가 훨씬 빠름)
-exec로 sms 전송함
-배치 프로그램에서는 프로시저를 많이 사용함. 대용량 데이터라 네트워크로 처리하기 버거울때가 있기 때문

<SMS dbo.s_c_i_insertSMS_prodweb>
exec [Insert_LMS] '01097377946' , '031-490-7443', '테스트입니다아~~~~~' , '', '', 'CKR' , '4' 

(4:sms, 6:mms)
exec는 프로시저를 호출하는것

cf) 트리거: 테이블에 insert, update, delete가 발생하면 어떤 작업을 시행하라. 
동시에 바로 작업할 수 있도록 하는 것. 요즘은 트리거보다는 API 호출시 메시지 시스템이 전체에게 뿌리면 구독하는 서비스가 캐치해서 날림.

cf) 사용자 정의 함수: 사실상 실제로 컴파일을 하지 않음. 사용 될때마다 쿼리 분석기가 분석해서 Optimizer(최적화) 하여 결과 출력함. 쿼리가 느려지는 단점이있다.

replace같이 내장함수는 컴파일이 되어있음. 웬만하면 사용자 정의 함수를 쓰지 않음. 데이터가 작다면 사용자 정의함수도 가능

USE [Database이름]
GO ->문장의 묶음 처리 단위를 구분

SET ANSI_NULLS ON  (--> where column_name = NULL을 사용하는 SELECT 문은 column_name에 Null이 있을때도 0행을 반환. 표준 // OFF 라면 NULL처리를 비표준으로 설정. 인덱스가 있는 테이블의 CRUD 연산 실패, 인덱스가 없는 것처럼 select 처리)
GO
SET QUOTED_IDENTIFIER ON (-->식별자는 ""로 구분, 리터럴은 ''로 구분 // OFF라면 식별자를 따옴표로 묶을 수 없으며 transact-SQL 식별자 규칙을 따름)
GO

변수선언: DECLARE @변수명 데이터타입
변수값에 대입: SET @변수명=값
변수값 출력: SELECT @변수명

데이터 타입이 테이블 형태라면 
DECLARE @변수명 테이블명(
	열이름 타입,
	열이름 타입,
)

BEGIN~END: 여러가지 Transact-SQL 문을 그룹으로 묶어서 실행할 수 있도록함, 중첩 가능

ALTER: 저장 프로시저 수정
DROP: 저장 프로시저 삭제

